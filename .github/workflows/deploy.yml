name: WDI Multi-Project Deploy with Enhanced Queue and Timeout Handling

on:
  push:
    branches:
    - wdi-training-cj.online
    - wdi-training-tommy-vercetti.online
    - wdi-training-franklin-clinton.online
    - wdi-training-trevor-philips.online
    - wdi-training-michael-de-santa.online
    - wdi-training-big-smoke.online
    - wdi-training-lester-crest.online
    - wdi-training-catalina.online
    - wdi-training-ryder.online
    - wdi-training-lance-vance.online
    - wdi-training-niko-bellic.online
    - wdi-training-roman-bellic.online
    - wdi-training-hernandez.online
    - wdi-training-ammu-nation-clerk.online
    - wdi-training-johnny-klebitz.online
    - wdi-training-patrick-mcreary.online
    - wdi-training-derrick-mcreary.online
    - wdi-training-ray-boccino.online
    - wdi-training-phil-bell.online
    - wdi-training-alexandra-chilton.online
    - wdi-training-michael-de-santa.online
    - wdi-training-tyler-dixon.online
    - wdi-training-lazlow.online
    - wdi-training-amanda-de-santa.online 
    - wdi-training-miguel-madrazo.online

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Set explicit timeout for the entire job
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      timeout-minutes: 5  # Timeout for checkout step
    
    - name: Extract project name and configure port
      id: project
      timeout-minutes: 2  # Timeout for project configuration
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        
        # Project to Port Mapping - CUSTOMIZE THESE PORTS
        declare -A PROJECT_PORTS
        PROJECT_PORTS["wdi-training-cj.online"]="5001"
        PROJECT_PORTS["wdi-training-tommy-vercetti.online"]="5002"
        PROJECT_PORTS["wdi-training-franklin-clinton.online"]="5003"
        PROJECT_PORTS["wdi-training-trevor-philips.online"]="5004"
        PROJECT_PORTS["wdi-training-michael-de-santa.online"]="5005"
        PROJECT_PORTS["wdi-training-big-smoke.online"]="5006"
        PROJECT_PORTS["wdi-training-lester-crest.online"]="5007"
        PROJECT_PORTS["wdi-training-catalina.online"]="5008"
        PROJECT_PORTS["wdi-training-ryder.online"]="5009"
        PROJECT_PORTS["wdi-training-lance-vance.online"]="5010"
        PROJECT_PORTS["wdi-training-niko-bellic.online"]="5011"
        PROJECT_PORTS["wdi-training-roman-bellic.online"]="5012"
        PROJECT_PORTS["wdi-training-hernandez.online"]="5013"
        PROJECT_PORTS["wdi-training-ammu-nation-clerk.online"]="5014"
        PROJECT_PORTS["wdi-training-johnny-klebitz.online"]="5015"
        PROJECT_PORTS["wdi-training-patrick-mcreary.online"]="5016"
        PROJECT_PORTS["wdi-training-derrick-mcreary.online"]="5017"
        PROJECT_PORTS["wdi-training-ray-boccino.online"]="5018"
        PROJECT_PORTS["wdi-training-phil-bell.online"]="5019"
        PROJECT_PORTS["wdi-training-alexandra-chilton.online"]="5020"
        PROJECT_PORTS["wdi-training-michael-de-santa.online"]="5021"
        PROJECT_PORTS["wdi-training-tyler-dixon.online"]="5022"
        PROJECT_PORTS["wdi-training-lazlow.online"]="5023"
        PROJECT_PORTS["wdi-training-amanda-de-santa.online"]="5024"
        PROJECT_PORTS["wdi-training-miguel-madrazo.online"]="5025"
        
        # Get port for current project
        PORT=${PROJECT_PORTS[$BRANCH_NAME]}
        
        if [ -z "$PORT" ]; then
          echo "‚ùå Error: No port configured for project $BRANCH_NAME"
          exit 1
        fi
        
        echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "path=/var/www/$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "port=$PORT" >> $GITHUB_OUTPUT
        
        echo "üöÄ Deploying project: $BRANCH_NAME"
        echo "üìÅ Path: /var/www/$BRANCH_NAME"
        echo "üåê Port: $PORT"
    
    - name: Deploy to server with enhanced queue and timeout handling
      uses: appleboy/ssh-action@v1.0.3
      timeout-minutes: 20  # Timeout for deployment step
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        command_timeout: 18m  # SSH command timeout (slightly less than step timeout)
        script: |
          PROJECT_NAME="${{ steps.project.outputs.name }}"
          PROJECT_PATH="${{ steps.project.outputs.path }}"
          PROJECT_PORT="${{ steps.project.outputs.port }}"
          
          # Enhanced queue system with timeouts
          LOCK_FILE="/tmp/wdi-deploy.lock"
          QUEUE_FILE="/tmp/wdi-deploy-queue.txt"
          MAX_QUEUE_WAIT_MINUTES=8  # Maximum time to wait in queue
          LOCK_TIMEOUT_MINUTES=15   # Maximum time a lock can be held
          
          echo "üöÄ Deployment request for: $PROJECT_NAME"
          echo "‚è∞ Time: $(date)"
          echo "‚è≥ Max queue wait: ${MAX_QUEUE_WAIT_MINUTES} minutes"
          
          # Cleanup old locks (older than LOCK_TIMEOUT_MINUTES)
          if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_FILE" 2>/dev/null || echo 0) ))
            LOCK_AGE_MINUTES=$(( LOCK_AGE / 60 ))
            
            if [ $LOCK_AGE_MINUTES -gt $LOCK_TIMEOUT_MINUTES ]; then
              echo "üßπ Removing stale lock file (${LOCK_AGE_MINUTES} minutes old)"
              rm -f "$LOCK_FILE"
            fi
          fi
          
          # Clean up old queue entries (older than 2 hours)
          if [ -f "$QUEUE_FILE" ]; then
            TEMP_QUEUE="/tmp/wdi-deploy-queue-temp.txt"
            CURRENT_TIME=$(date +%s)
            
            while IFS='|' read -r name path port timestamp; do
              if [ -n "$timestamp" ]; then
                ENTRY_TIME=$(date -d "$timestamp" +%s 2>/dev/null || echo 0)
                AGE_HOURS=$(( (CURRENT_TIME - ENTRY_TIME) / 3600 ))
                
                if [ $AGE_HOURS -le 2 ]; then
                  echo "$name|$path|$port|$timestamp" >> "$TEMP_QUEUE"
                else
                  echo "üóëÔ∏è Removing old queue entry: $name (${AGE_HOURS}h old)"
                fi
              fi
            done < "$QUEUE_FILE"
            
            if [ -f "$TEMP_QUEUE" ]; then
              mv "$TEMP_QUEUE" "$QUEUE_FILE"
            else
              rm -f "$QUEUE_FILE"
            fi
          fi
          
          # Add this deployment to the queue with unique identifier
          QUEUE_ID="${PROJECT_NAME}_$(date +%s)_$$"
          echo "$QUEUE_ID|$PROJECT_NAME|$PROJECT_PATH|$PROJECT_PORT|$(date)" >> "$QUEUE_FILE"
          
          # Queue processing with timeout
          echo "üìã Checking deployment queue..."
          QUEUE_START_TIME=$(date +%s)
          
          while true; do
            # Check if we've been waiting too long
            CURRENT_TIME=$(date +%s)
            WAIT_TIME_MINUTES=$(( (CURRENT_TIME - QUEUE_START_TIME) / 60 ))
            
            if [ $WAIT_TIME_MINUTES -ge $MAX_QUEUE_WAIT_MINUTES ]; then
              echo "‚è∞ Queue timeout reached (${WAIT_TIME_MINUTES} minutes). Aborting deployment."
              # Remove ourselves from queue
              grep -v "^$QUEUE_ID|" "$QUEUE_FILE" > "$QUEUE_FILE.tmp" 2>/dev/null && mv "$QUEUE_FILE.tmp" "$QUEUE_FILE" || true
              exit 1
            fi
            
            # Try to get the lock with timeout
            if (set -C; echo $$ > "$LOCK_FILE") 2>/dev/null; then
              echo "üîí Got deployment lock"
              
              # Check if we're next in queue
              NEXT_ENTRY=$(head -n1 "$QUEUE_FILE" 2>/dev/null)
              NEXT_QUEUE_ID=$(echo "$NEXT_ENTRY" | cut -d'|' -f1)
              NEXT_PROJECT=$(echo "$NEXT_ENTRY" | cut -d'|' -f2)
              
              if [ "$NEXT_QUEUE_ID" = "$QUEUE_ID" ]; then
                echo "‚úÖ Our turn to deploy!"
                
                # Remove ourselves from queue
                sed -i "1d" "$QUEUE_FILE" 2>/dev/null || true
                
                break
              else
                echo "‚è≥ Not our turn yet. Next: $NEXT_PROJECT (waited ${WAIT_TIME_MINUTES}/${MAX_QUEUE_WAIT_MINUTES} min)"
                # Release lock and wait
                rm -f "$LOCK_FILE"
                sleep 5  # Reduced sleep time for faster queue processing
              fi
            else
              LOCK_HOLDER=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
              echo "üîê Another deployment in progress (PID: $LOCK_HOLDER), waiting... (${WAIT_TIME_MINUTES}/${MAX_QUEUE_WAIT_MINUTES} min)"
              sleep 5
            fi
          done
          
          # Enhanced cleanup function
          cleanup() {
            echo "üßπ Cleaning up deployment lock and queue entry"
            rm -f "$LOCK_FILE"
            # Remove any remaining queue entries for this deployment
            if [ -f "$QUEUE_FILE" ]; then
              grep -v "^$QUEUE_ID|" "$QUEUE_FILE" > "$QUEUE_FILE.tmp" 2>/dev/null && mv "$QUEUE_FILE.tmp" "$QUEUE_FILE" || true
            fi
          }
          trap cleanup EXIT
          
          # Set deployment timeout
          DEPLOY_START_TIME=$(date +%s)
          MAX_DEPLOY_MINUTES=12
          
          # Function to check deployment timeout
          check_deploy_timeout() {
            CURRENT_TIME=$(date +%s)
            DEPLOY_TIME_MINUTES=$(( (CURRENT_TIME - DEPLOY_START_TIME) / 60 ))
            
            if [ $DEPLOY_TIME_MINUTES -ge $MAX_DEPLOY_MINUTES ]; then
              echo "‚è∞ Deployment timeout reached (${DEPLOY_TIME_MINUTES} minutes). Aborting."
              exit 1
            fi
          }
          
          # Deployment process with timeout checks
          echo "üöÄ Starting deployment for: $PROJECT_NAME"
          echo "üìÅ Target directory: $PROJECT_PATH"
          echo "üåê Application port: $PROJECT_PORT"
          echo "‚è∞ Deployment started at: $(date)"
          echo "‚è≥ Max deployment time: ${MAX_DEPLOY_MINUTES} minutes"
          
          check_deploy_timeout
          
          # Check if project directory exists
          if [ ! -d "$PROJECT_PATH" ]; then
            echo "‚ùå Error: Project directory $PROJECT_PATH does not exist!"
            echo "üìã Available WDI projects in /var/www/:"
            ls -la /var/www/ | grep "wdi-training" || echo "No WDI projects found"
            exit 1
          fi
          
          # Navigate to project directory
          cd "$PROJECT_PATH"
          echo "üìç Current directory: $(pwd)"
          
          check_deploy_timeout
          
          # Show current git status
          echo "üìä Current git status:"
          git status --porcelain
          
          # Stash any local changes if they exist
          if [ -n "$(git status --porcelain)" ]; then
            echo "üíæ Stashing local changes..."
            timeout 60 git stash push -m "Auto-stash before deploy $(date)" || {
              echo "‚ö†Ô∏è Git stash timed out or failed, continuing..."
            }
          fi
          
          check_deploy_timeout
          
          # Fetch and reset to latest from the specific branch
          echo "üîÑ Fetching latest changes from branch: $PROJECT_NAME"
          timeout 120 git fetch origin "$PROJECT_NAME" || {
            echo "‚ùå Failed to fetch from branch: $PROJECT_NAME"
            echo "üìã Available remote branches:"
            git branch -r
            exit 1
          }
          
          timeout 60 git reset --hard "origin/$PROJECT_NAME" || {
            echo "‚ùå Failed to reset to origin/$PROJECT_NAME"
            exit 1
          }
          echo "‚úÖ Successfully updated to latest commit"
          
          check_deploy_timeout
          
          # Check if package.json exists
          if [ ! -f "package.json" ]; then
            echo "‚ùå Error: package.json not found in $PROJECT_PATH"
            echo "üìã Files in directory:"
            ls -la
            exit 1
          fi
          
          # Update/Create .env.local with correct port
          echo "üîß Configuring application port..."
          
          # Backup existing .env.local if it exists
          if [ -f ".env.local" ]; then
            cp .env.local .env.local.backup.$(date +%Y%m%d_%H%M%S)
          fi
          
          # Update or add PORT in .env.local
          if [ -f ".env.local" ]; then
            # Remove existing PORT line if it exists
            sed -i '/^PORT=/d' .env.local
          fi
          
          # Add the correct port
          echo "PORT=$PROJECT_PORT" >> .env.local
          echo "‚úÖ Port $PROJECT_PORT configured in .env.local"
          
          check_deploy_timeout
          
          # Install dependencies with timeout
          echo "üì¶ Installing dependencies..."
          if [ -f "package-lock.json" ]; then
            echo "Using npm ci for faster, reliable builds..."
            timeout 300 npm ci || {
              echo "‚ùå npm ci timed out or failed"
              exit 1
            }
          elif [ -f "yarn.lock" ]; then
            echo "Using yarn for dependency installation..."
            timeout 300 yarn install --frozen-lockfile || {
              echo "‚ùå yarn install timed out or failed"
              exit 1
            }
          else
            echo "Using npm install..."
            timeout 300 npm install || {
              echo "‚ùå npm install timed out or failed"
              exit 1
            }
          fi
          
          check_deploy_timeout
          
          # Build the Next.js application with timeout
          echo "üî® Building Next.js application..."
          if timeout 480 npm run build; then
            echo "‚úÖ Build completed successfully!"
          else
            echo "‚ùå Build failed or timed out for $PROJECT_NAME"
            echo "üìã Checking npm scripts:"
            npm run 2>/dev/null || echo "Could not list npm scripts"
            exit 1
          fi
          
          check_deploy_timeout
          
          # Restart the application
          echo "üîÑ Restarting application on port $PROJECT_PORT..."
          
          # Kill any existing process on this port
          echo "üõë Stopping any existing process on port $PROJECT_PORT..."
          timeout 30 fuser -k ${PROJECT_PORT}/tcp 2>/dev/null || echo "No existing process found on port $PROJECT_PORT"
          
          # Wait a moment for the port to be released
          sleep 2
          
          # Method 1: PM2 (recommended)
          if command -v pm2 >/dev/null 2>&1; then
            if pm2 list | grep -q "$PROJECT_NAME"; then
              echo "üîÑ Restarting existing PM2 process: $PROJECT_NAME"
              timeout 60 pm2 restart "$PROJECT_NAME" || {
                echo "‚ö†Ô∏è PM2 restart timed out, trying to delete and recreate..."
                pm2 delete "$PROJECT_NAME" 2>/dev/null || true
                sleep 2
                PORT=$PROJECT_PORT pm2 start npm --name "$PROJECT_NAME" -- start
              }
            else
              echo "üÜï Starting new PM2 process: $PROJECT_NAME on port $PROJECT_PORT"
              PORT=$PROJECT_PORT pm2 start npm --name "$PROJECT_NAME" -- start
            fi
            pm2 save
            echo "‚úÖ PM2 process updated and saved"
          
          # Method 2: Systemd service
          elif systemctl is-active --quiet "$PROJECT_NAME" 2>/dev/null; then
            echo "üîÑ Restarting systemd service: $PROJECT_NAME"
            timeout 60 sudo systemctl restart "$PROJECT_NAME" || {
              echo "‚ùå Systemd restart timed out or failed"
              exit 1
            }
            echo "‚úÖ Systemd service restarted"
          
          # Method 3: Custom restart script
          elif [ -f "restart.sh" ]; then
            echo "üìú Running custom restart script..."
            chmod +x restart.sh
            timeout 120 env PORT=$PROJECT_PORT ./restart.sh || {
              echo "‚ùå Custom restart script timed out or failed"
              exit 1
            }
            echo "‚úÖ Custom restart script executed"
          
          # Method 4: Direct npm start with nohup
          else
            echo "üÜï Starting application directly with npm..."
            nohup env PORT=$PROJECT_PORT npm start > /dev/null 2>&1 &
            echo "‚úÖ Application started in background"
          fi
          
          # Health check with timeout
          echo "üè• Performing health check on port $PROJECT_PORT..."
          sleep 3
          
          HEALTH_URL="http://localhost:$PROJECT_PORT"
          
          # Try health check multiple times with timeout
          HEALTH_ATTEMPTS=0
          MAX_ATTEMPTS=6
          
          while [ $HEALTH_ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            if timeout 10 curl -f "$HEALTH_URL" >/dev/null 2>&1; then
              echo "‚úÖ Health check passed: $HEALTH_URL"
              break
            else
              HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
              echo "‚è≥ Health check attempt $HEALTH_ATTEMPTS/$MAX_ATTEMPTS failed, retrying in 5 seconds..."
              sleep 5
            fi
            check_deploy_timeout
          done
          
          if [ $HEALTH_ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "‚ö†Ô∏è Health check failed after $MAX_ATTEMPTS attempts"
            echo "üìç Checking if process is running..."
            if pgrep -f "next start" > /dev/null; then
              echo "‚úÖ Next.js process is running"
            else
              echo "‚ùå Next.js process not found"
            fi
            
            echo "üìç Checking port usage..."
            netstat -tulpn | grep ":$PROJECT_PORT " || echo "Port $PROJECT_PORT not in use"
          fi
          
          # Final timeout check
          check_deploy_timeout
          
          # Summary
          DEPLOY_END_TIME=$(date +%s)
          TOTAL_DEPLOY_TIME=$(( (DEPLOY_END_TIME - DEPLOY_START_TIME) / 60 ))
          
          echo ""
          echo "üéâ Deployment Summary for $PROJECT_NAME:"
          echo "   üìÅ Location: $PROJECT_PATH"
          echo "   üåê URL: $HEALTH_URL"
          echo "   üîå Port: $PROJECT_PORT"
          echo "   ‚è∞ Started at: $(date -d @$DEPLOY_START_TIME)"
          echo "   ‚è∞ Completed at: $(date)"
          echo "   ‚è±Ô∏è Total time: ${TOTAL_DEPLOY_TIME} minutes"
          echo "   ‚úÖ Status: SUCCESS"
          echo ""